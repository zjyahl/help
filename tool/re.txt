\bhi \bhi\b
\b(?<Word>\w+)\b\s+\k<Word>\b          (?<Word>    k<Word>)
\b\w+(?=ing\b)                         (?=ing    零宽度正预测先行断言 以ing结尾的单词的前面部分(除了ing以外的部分)
(?<=\bre)\w+\b                         (?<=\bre 零宽度正回顾后发断言   re开头的单词的后半部分(除了re以外的部分))
捕获 	
(exp) 	匹配exp,并捕获文本到自动命名的组里
(?<name>exp) 	匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)
(?:exp) 	匹配exp,不捕获匹配的文本，也不给此分组分配组号
零宽断言 	
(?=exp) 	匹配exp前面的位置
(?<=exp) 	匹配exp后面的位置
(?!exp) 	匹配后面跟的不是exp的位置
(?<!exp) 	匹配前面不是exp的位置
注释 	
(?#comment) 	这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读
(?<=<(\w+)>).*(?=<\/\1>)                  (\1 第一个分组)
2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)


(?'group') 把捕获的内容命名为group,并压入堆栈(Stack)
(?'-group') 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败
(?(group)yes|no) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分
(?!) 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败

<div[^>]*>[^<>]*(((?'Open'<div[^>]*>)[^<>]*)+((?'-Open'</div>)[^<>]*)+)*(?(Open)(?!))</div>
<                         #最外层的左括号
    [^<>]*                #最外层的左括号后面的不是括号的内容
    (
        (
            (?'Open'<)    #碰到了左括号，在黑板上写一个"Open"
            [^<>]*       #匹配左括号后面的不是括号的内容
        )+
        (
            (?'-Open'>)   #碰到了右括号，擦掉一个"Open"
            [^<>]*        #匹配右括号后面不是括号的内容
        )+
    )*
    (?(Open)(?!))         #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的"Open"；如果还有，则匹配失败

>                         #最外层的右括号
